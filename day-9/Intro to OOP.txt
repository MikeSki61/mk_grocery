Day 9: Intro to Object-Oriented Programming 

What Is Object-Oriented Programming?
Object-Oriented Programming (OOP) is a way to write code by organizing it 
into objects. These objects are modeled after real-world things—they have 
properties (what they are) and actions (what they can do).
For example, think of a pizza:
It has properties like size, toppings, and crust type.


It has actions like bake(), slice(), and serve().


By structuring code in this way, it becomes easier to manage as projects 
grow in size and complexity.


Why Is OOP Important?
You might be used to grouping code into functions inside modules. That works
 well for smaller projects, but as codebases expand, things can get messy.
OOP helps by:
Reusing code: You don’t need to rewrite the same logic—objects and methods 
can be reused across your project.


Staying organized: Code related to the same thing stays grouped together 
inside a class.


Making bugs easier to fix: When something breaks, it’s easier to track down 
which object or method is responsible.





The Four Pillars of OOP
These are the four foundational ideas behind OOP:
Encapsulation
 Think of it like putting important data inside a box. The only way to interact
 with it is through the tools (methods) you provide.
 Example: You can only add or remove toppings from a Pizza using specific 
 methods like add_topping().


Inheritance
 One class can inherit features from another.
 Example: A PepperoniPizza class can inherit from a more general Pizza class, 
 and then add its own specific features.


Polymorphism
 A single action can behave differently depending on the object that uses it.
 Example: Both SmallPizza and LargePizza can have a method called cut(), 
 but each one cuts differently.


Abstraction
 This means showing only what’s necessary and hiding the rest.
 Example: A Payment class might handle how to pay for a pizza, but you don’t
  need to know the details of how a credit card is processed.




A Simple Example in Python
class Food:
    def __init__(self, name, color):
        self.name = name
        self.color = color

    def describe(self):
        return f"{self.name} is {self.color}."

apple = Food("Apple", "red")
banana = Food("Banana", "yellow")

print(apple.describe())   # Output: Apple is red.
print(banana.describe())  # Output: Banana is yellow.


Food is a class—a blueprint for creating objects.


apple and banana are objects created from that blueprint.


The method describe() tells us about each food object.

