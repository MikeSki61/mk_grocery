Day 9: Classes and Objects

What Are Classes and Objects?
In Object-Oriented Programming (OOP), classes and objects are fundamental concepts.
A class is like a blueprint—it describes how something is built and what it can do.


An object is a specific copy created from that blueprint.


Back to our alien example, Let’s say you were abducted by aliens and they scan your DNA and create a class called Human. From this class, they generate clones of you—each clone is an object, based on the same design but with its own traits.



Class and Objects Example
Here’s a simple Python example that shows how to define a class and create objects from it:
# Defining the Human class
class Human:
    def __init__(self, name, iq):
        self.name = name
        self.iq = iq

    def introduce(self):
        if self.iq < 69:
            print(f"Me {self.name}. Me find rock. Me smash rock. Rock make fire")
        else:
            print(f"Hi, I'm {self.name}, I am a bi-pedal carbon based lifeform.")

# Creating objects (clones) from the Human class
original_human = Human("Bob", 100)
clone_1 = Human("Jeff", 140)
clone_2 = Human("Grog", 28)

# Calling the method for each object
original_human.introduce()
clone_1.introduce()
clone_2.introduce()







What’s happening in the code:
Human is the class (blueprint).
original_human, clone_1, and clone_2 are objects created from that blueprint.
Each object has its own attributes (name, iq) and can use the class’s method (introduce()).


Each object behaves according to the values you give it. Even though they come from the same class, their behavior can vary based on their attributes—just like clones with different personalities or abilities.

Copy the code and try it out yourself. Play with the name and iq values. 



Why Use Classes and Objects?
Here’s why classes and objects are powerful tools in Python:
Reusability: Once you write a class, you can create as many objects from it as you want—no need to rewrite the logic.


Modularity: Each object is self-contained. Changes to one won’t break the others.


Clarity: Grouping related data (attributes) and behavior (methods) makes your code much easier to read and maintain.


Using our alien example:
Instead of rewriting the cloning logic every time, the alien just uses the Human class again and again. Each clone can be slightly different but still created with the same blueprint.
You can even use loops or store objects in lists and dictionaries to create many of them quickly.

Quick Recap
Classes are blueprints that define how objects are built and what they can do.
Objects are specific instances created from a class.
We briefly explored attributes (like name and iq) and methods (like introduce()).
Objects can have different data but share the same structure and behaviors.



