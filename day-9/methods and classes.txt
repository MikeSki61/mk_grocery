Day 9: Methods

What Are Methods?
Methods are functions that live inside a class and define how an object 
behaves. Think of them as the "actions" your objects can perform.
In Python, there are three main types of methods:
Instance Methods – Act on one specific object


Class Methods – Act on the class as a whole


Static Methods – Don’t act on either; they’re just handy tools

Why Use Methods?
Methods help organize and group code that belongs to the same object or 
class, making your code:
Easier to read


Easier to maintain


Easier to reuse

Instance Methods
➤ What They Are:
Operate on a specific instance (object) of a class.


Can access and change instance attributes (data tied to that specific object).


Always have self as their first parameter.

Example:
class CoffeeOrder:
    def __init__(self):
        self.orders = []

    def add_order(self, drink):
        self.orders.append(drink)
        print(f"{drink} added to your order.")

    def cancel_order(self, drink):
        if drink in self.orders:
            self.orders.remove(drink)
            print(f"{drink} removed from your order.")
        else:
            print(f"{drink} not found in your order.")

    def show_order(self):
        print("Your Order:", ", ".join(self.orders))




Class Methods
➤ What They Are:
Affect the entire class, not just one object.


Use @classmethod decorator.


First parameter is cls (class reference).


Can access or modify class-level data, which is shared across all instances.

Example:
class CoffeeOrder:
    total_orders = 0

    def __init__(self):
        self.orders = []
        CoffeeOrder.total_orders += 1

    @classmethod
    def get_total_orders(cls):
        return cls.total_orders



Static Methods
➤ What They Are:
Do not need access to self (instance) or cls (class).


Use @staticmethod decorator.


Behave like regular functions but are placed inside a class for organization.

Example:
class CoffeeOrder:
    @staticmethod
    def is_valid_drink(drink):
        return isinstance(drink, str) and bool(drink.strip())




Additional Methods
It is true that the 3 main methods in python are instance methods,
 class methods and static methods, however you can categorize other 
 special-purpose or advanced methods too. Here are some one you might 
 hear about:

Dunder Methods: 
Also called special methods, these are methods with double underscores 
like __init__, __str__, __len__, __getitem__, etc.
They customize how your objects behave with Python's built-in functions 
and operators.

Property Methods:
These are methods turned into attributes using the @property decorator. 
They allow you to access method results like regular variables.

Abstract Methods:
These are methods that must be implemented in subclasses. They’re declared 
using the @abstractmethod decorator in abstract base classes.

Coroutine Methods: 
If you’re writing asynchronous code (with asyncio), then your methods can 
also be coroutines using async def.

Practice Exercises
Exercise 1 - Instance Methods
Using the Instance Method example (copy into a practice module):
Create an instance of CoffeeOrder() (i.e. my_order = CoffeeOrder())
Add three different type of coffee beverages to self.orders 
(i.e. my_order.add_order("Latte"))
Remove one of the coffee from self.orders (i.e. my_order.cancel_order("Latte"))
Print self.orders (i.e. my_order.show_order())
Add an instance method that clears self.orders.
	def clear_orders(self):
    """Clears the entire order list."""
    self.orders = []
    print("Your order has been cleared.")


Exercise 2 - Class Methods
Using the Class Method example:
Create five instances of of CoffeeOrder (i.e. order1 = CoffeeOrder())
Print the total number of coffee orders using the class method 
get_total_orders (i.e. CoffeeOrder.get_total_orders())


Exercise 3 - Static Methods
Using the Static Method example:
Check if these items are valid drinks (“Cappuccino”, 7, “Latte”)
I.e. print(CoffeeOrder.is_valid_drink("Americano")

