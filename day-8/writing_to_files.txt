# #========================WRITING TO THE  FILE ===========================================================
# Day 8: Files - Reading, Writing & Permissions

# In the last few modules, we explored the core concepts of file operations in Python—how to write, read, and handle files safely. We focused on practical methods like write, writelines, read, readline, and readlines, along with strategies for managing file permissions and preventing errors.
# This document goes a step further. Here, we’ll dive deeper into the specifics, providing detailed explanations, step-by-step guides, and examples that will help you work with files in Python. Let’s get started


# Writing Files
# File writing is a fundamental skill in Python that allows you to save data for later use. In this section, we’ll break down the process into clear steps and explain the key methods and concepts.
# Opening a File in Write Mode
# To write data to a file, the file must first be opened in write mode (w). Here’s how it works:
# Purpose: Write mode creates a new file if it doesn’t exist or overwrites the content of an existing file.
# Syntax: Use the open() function with 'w' as the mode.
# file = open('example.txt', 'w')

# Important Note: Opening a file in write mode will erase all existing content.

# Writing a Single String
# The write() method allows you to write a single string to the file.

# Usage: Perfect for small, straightforward data additions.
# file.write("Hello, World!")


# Key Point: The write() method doesn’t automatically add a newline (\n). You must include it manually if needed.
# file.write("Hello, World!\n")



# Writing Multiple Lines with writelines()
# For adding multiple strings at once, use the writelines() method.

# How It Works: Pass a list of strings to writelines().
# lines = ["First line\n", "Second line\n", "Third line\n"]
# file.writelines(lines)


# Key Limitation: writelines() doesn’t add newlines automatically. Include \n in each string if needed.

# Appending to an Existing File
# If you want to add content to an existing file without overwriting it, open the file in append mode (a).

# Syntax:
# file = open('example.txt', 'a')


# Behavior: Content is added to the end of the file, preserving existing data.



# Reading Files
# Once data is written to a file, the next step is to read it back when needed. Python provides several methods for reading files efficiently. This section explains the different methods, their use cases, and best practices.

# Opening a File in Read Mode
# Before reading from a file, it must be opened in read mode (r).

# Purpose: Read mode allows you to access the content of a file without modifying it.
# Syntax:
# file = open('example.txt', 'r')


# Default Mode: If no mode is specified, Python opens the file in read mode by default.






# Reading the Entire File with read()
# The read() method reads the entire content of a file as a single string.

# Usage: Best for small files where you need all the content at once.
# with open('example.txt', 'r') as file:
#     content = file.read()
#     print(content)


# Key Point: For large files, read() can consume significant memory. Avoid using it on very large files.

# Reading a Single Line with readline()
# The readline() method reads a single line from the file.

# Usage: Useful when processing a file line-by-line.
# with open('example.txt', 'r') as file:
#     line = file.readline()
#     print(line)


# Behavior: Subsequent calls to readline() will return the next line until the end of the file.




# Reading All Lines into a List with readlines()
# The readlines() method reads all lines from the file and returns them as a list.

# Usage: Ideal when you need to work with lines as separate elements.
# with open('example.txt', 'r') as file:
#     lines = file.readlines()
#     print(lines)


# Key Point: Each line in the list includes its newline character (\n), unless the file is processed otherwise.

# Iterating Through a File
# For large files, iterating through the file object is memory-efficient and straightforward.

# Example:
# with open('example.txt', 'r') as file:
#     for line in file:
#         print(line.strip()) 

# Note: .strip() Removes trailing newline characters

# Advantage: Efficient for handling very large files as it reads one line at a time.



# Managing Permissions and Handling Errors in File Operations
# When working with files, it’s essential to handle potential issues like missing files, restricted permissions, or unexpected errors. This section explains how Python handles file permissions and demonstrates techniques to gracefully manage errors.

# Iterating Through a File
# File operations can fail for several reasons:

# The file doesn’t exist.
# The program lacks the necessary permissions to read or write.
# The file is locked or being used by another process.

# Understanding these scenarios helps you write code that can handle them gracefully.








# Understanding File Permissions
# File permissions in Unix-like systems (Linux, macOS) determine who can read, write, or execute a file. Permissions are represented both symbolically (using r, w, x) and numerically (using octal numbers like 644 or 755).

# Common permission types include:
# Read (r): Allows viewing the file content.
# Write (w): Allows modifying or deleting the file.
# Execute (x): Allows running the file as a program.

# For directories:
# Read: Allows listing files in the directory.
# Write: Allows creating or deleting files in the directory.
# Execute: Allows navigating into the directory.

# Each file or directory has three permission groups:
# Owner: The user who owns the file.
# Group: A group of users who have specific permissions.
# Others: All other users
# Example:
# -rw-r--r-- (indicates read/write for the owner, and read-only for others)




# Checking Permissions
# Linux/macOS: Use ls -l in the terminal to view permissions. 
# ls -l example.txt


# Windows: Right-click the file → Properties → Security
# Because we have bash in our terminal we will follow the same process as macOS and Linux users
# Example:
# -rw-r--r--


# This breaks down as:
# -: Indicates a regular file (or d for directories).
# rw-: Permissions for the owner (read and write).
# r--: Permissions for the group (read-only).
# r--: Permissions for others (read-only).







# Numeric (Octal) Representation of Permissions
# Permissions can also be represented as a three-digit octal number:

# Value
# Permission
# Symbol
# 0
# Np permission
# ---
# 1
# Execute only
# --x
# 2
# Write only
# -w-
# 3
# Write + Execute
# -wx
# 4
# Read only
# r--
# 5
# Read + Execute
# r-x
# 6
# Read + Write
# rw-
# 7
# Read + Write + Execute
# rwx


# Changing Permissions
# Use the chmod command to set permissions. (chmod stands for change mode)

# Command Syntax:
# chmod [permissions] [file]


# Example:
# chmod +w example.txt  # Add write permission
# chmod 644 example.txt  # Set specific permissions



# Using os to Change Permissions
# You can also change permission using the os library. However you cannot use the symbolic representation, you must use 0o and provide an octal. 
# os.chmod("example.txt", 0o644)


# Handling Permission Errors with try-except
# Python allows you to catch file-related errors using try-except blocks. This prevents your program from crashing unexpectedly.
# try:
#     with open('example.txt', 'w') as file:
#         file.write("Hello, World!")
# except PermissionError:
#     print("Permission denied: Unable to write to the file.")


# Other Common Errors:
# FileNotFoundError: Raised when trying to access a non-existent file.
# IsADirectoryError: Raised when trying to open a directory as a file.
# IOError: General input/output error.



# Combining Error Handling and with open
# The with open statement can be combined with try-except for safe and efficient file operations.

# Example:
# try:
#     with open('example.txt', 'r') as file:
#         content = file.read()
#         print(content)
# except PermissionError:
#     print("Error: You do not have the necessary permissions.")



# Best Practices for Handling File Errors
# Always Check for File Existence: Use os.path.exists() before attempting to access a file.
# Validate User Permissions: Ensure the program has the correct permissions before performing file operations.
# Fail Gracefully: Catch exceptions and provide meaningful error messages to the user.
# Log Errors: Use a logging mechanism to record errors for debugging.
# We will cover this in an upcoming module



#============================= EXEERCISES =========================


# Write the Grocery List
grocery_list = ['eggs', 'milk', 'butter']
def write_grocery_list():
    
    with open("grocery_list.txt", "w") as file:
        for item in grocery_list:
            file.write(item + "\n")

print(grocery_list)
print("Grocery list written in file.")

grocery_list = ['eggs', 'milk', 'butter']

file = open('grocery_list.txt', 'w')
file.writelines(grocery_list)

file.write("writing to the file using 'w' mode.\n")

file.close()
print('File has been written successfully')

with open('grocery_list', 'r')as file:
    lines = file.readlines()
    print(lines)

try:
    with open('grocery_list.txt', 'w') as file:
        file.write("Hello, World!")
except PermissionError:
    print("Permission denied: Unable to write to the file.")

# Day 8 Files- Escape Sequences

# # Exercise 1: Format a Menu
# # Write a string that displays the following text using escape sequences:
# # Menu:
# # 	1. Pizza
# # 	2. Burger
# # 	3. Salad

# file = ("Menu:\n1.Pizza\n2.Burger \n3.Salad")
# print(file)


# #Exercise 2: File Path with Raw Strings
# # Create a raw string to represent the following file path:
# # C:\Users\Chef\Documents\Recipes\desserts.txt
# recipe_path = r"C:\Users\Chef\Documents\Recipes\desserts.txt"
# print(recipe_path)


# # Exercise 3: Quotes in a Recipe
# # Write a string that includes the following sentence:
# # The chef said, "It's the best cake ever!"
# cake = 'The chef said, "It\'s the best cake ever!\"'
# print(cake)





